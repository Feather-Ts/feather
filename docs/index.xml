<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Feather TS</title>
    <link>//localhost:1313/</link>
    <description>Recent content on Feather TS</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 06 Apr 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="//localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>A component framework.</title>
      <link>//localhost:1313/</link>
      <pubDate>Wed, 06 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/</guid>
      <description>Feather-Ts is a light-weight and easily extendable ui framework written in TypeScript. You can use it to write embeddable components or single page applications for mobile and desktop alike. Regardless of its tiny footprint it is self-contained and provides templating, routing, messaging, event handling and rest api integration out of the box.
It relies heavily on decorators and grants the developer the freedom to subclass their components from anything they want.</description>
    </item>
    
    <item>
      <title>Getting started</title>
      <link>//localhost:1313/get-started/</link>
      <pubDate>Tue, 05 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/get-started/</guid>
      <description>Installation npm install @feather-ts/feather-ts --save
Components Feather provides two interfaces to turn any class into a component: Widget and ArrayWidget. Widget has a method init(el: Element) which is called when the component has been mounted to the dom. ArrayWidget tags classes that are added to arrays of a parent component. It has no init method, because initialization can be done in its constructor.
 Since feather has logic-less templates, the only way to swap out dom elements is via array bindings All decorators should be attached to the leaf class of a component.</description>
    </item>
    
    <item>
      <title>Decorators</title>
      <link>//localhost:1313/decorators/</link>
      <pubDate>Mon, 04 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/decorators/</guid>
      <description>Construct @Construct({selector: string, singleton: boolean})
The only class decorator in feather that indicates where in the DOM this component should be mounted to. You can mount components to arbitrary css selectors, which allows to create mixins of components. The singleton flag is used in combination with the @Inject decorator. Each widget should implement the interface Widget or ArrayWidget respectively.
 Make sure the classes are imported in the correct order.</description>
    </item>
    
    <item>
      <title>Examples</title>
      <link>//localhost:1313/examples/</link>
      <pubDate>Sun, 03 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/examples/</guid>
      <description>Routing Routing is simply done by having one page container component with a bunch of @Route() decorated methods and one single-item array binding for the pages to show. Now from within the routing methods replace the array item with a new page.
myPages: Page[] = [] @Route(&#39;/login&#39;) onPath(params) { this.myPage.splice(0, 1, new LoginPage()) } @Route(&#39;/project/:id&#39;) onPath(params) { const project = await this.fetchProject(params.id) this.myPage.splice(0, 1, new ProjectPage(project)) }  Swapping components This can be achieved like in routing or by simply adding a template attribute to a tag.</description>
    </item>
    
    <item>
      <title>Packaging &amp; Deploying</title>
      <link>//localhost:1313/packaging/</link>
      <pubDate>Sat, 02 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/packaging/</guid>
      <description>Packaging You can use browserify, parcel-bundler or any other existing technology to pack and bundle feather applications.
Imports Right you can use all feather-ts parts by importing the files directly from NPM:
import {Construct} from &#39;@feather-ts/feather-ts/dist/decorators/construct&#39;
There will be a commonjs and es6 bundles distribution available too, but we recommend to include only the bits and pieces required for your own app, instead of the full bundled package.</description>
    </item>
    
    <item>
      <title>Help</title>
      <link>//localhost:1313/help/</link>
      <pubDate>Fri, 01 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/help/</guid>
      <description>IE11 support Feather-ts comes without old browser support. However it does work with IE11, if polyfills are provided. You will need es6 shims, Promise, Fetch and CustomEvent polyfills.
Bindings and DOM writes Feather has no virtual dom, but since the templates are logicless the dom writes are optimized in place. You get maximum performance without the overhead of diffing parts of the DOM tree. Because of that feather also plays nicely with others and doesn&amp;rsquo;t care if the DOM is modified by external scripts.</description>
    </item>
    
  </channel>
</rss>